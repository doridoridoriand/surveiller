# クロスコンパイルについて

## 現在の手法

deadman-goでは、UbuntuランナーでGoのクロスコンパイル機能を使用してmacOS用バイナリをビルドしています。

## なぜ問題ないのか

### 1. Goの設計思想
- Goは最初からクロスプラットフォーム対応を念頭に設計
- `GOOS`と`GOARCH`環境変数で簡単にターゲットプラットフォーム指定可能
- CGOを使用しない限り、完全にクロスプラットフォーム対応

### 2. deadman-goの依存関係
使用している全ての依存関係はPure Goライブラリ：
- `github.com/gdamore/tcell/v2` - Pure Go TUIライブラリ
- `github.com/leanovate/gopter` - Pure Go プロパティベーステスト
- `golang.org/x/net` - Go標準拡張ネットワークライブラリ

### 3. 業界標準
多くの有名なGoプロジェクトが同様の手法を採用：
- **Docker**: UbuntuランナーでWindows/macOS用バイナリをビルド
- **Kubernetes**: 全プラットフォーム向けバイナリをLinux環境でビルド
- **Hugo**: クロスコンパイルで30以上のプラットフォーム対応
- **Prometheus**: 全てのリリースバイナリをLinux環境でクロスコンパイル

## 設定の最適化

### CGO無効化
```yaml
env:
  CGO_ENABLED: 0
```
- CGOを明示的に無効化してクロスコンパイルを確実に
- 静的リンクされたバイナリを生成
- 依存関係のないポータブルなバイナリ

### ファイル形式検証
```bash
file dist/*
```
- 生成されたバイナリの形式を確認
- 正しいアーキテクチャ向けにビルドされているか検証

## 代替手法との比較

### 1. macOS専用ランナー使用
**メリット:**
- ネイティブ環境でのビルド
- macOS固有の機能テスト可能

**デメリット:**
- ビルド時間が長い（macOSランナーは遅い）
- コストが高い（macOSランナーは10倍のコスト）
- 複雑な設定が必要

### 2. 現在の手法（推奨）
**メリット:**
- 高速ビルド
- 低コスト
- シンプルな設定
- 業界標準

**デメリット:**
- macOS固有の機能テストは別途必要

## 品質保証

### 1. 自動テスト
- クロスコンパイルされたバイナリの動作確認
- バージョン情報の正確性確認

### 2. 手動テスト（推奨）
リリース前にmacOS環境での手動テスト：
```bash
# macOS環境で実行
./deadman-go-darwin-amd64 -version
./deadman-go-darwin-arm64 -version
```

### 3. コミュニティフィードバック
- GitHub Issuesでの動作報告
- 実際のユーザーからのフィードバック

## 結論

**現在の手法は適切で業界標準です。**

deadman-goのようなネットワークツールでは：
- Pure Goライブラリのみ使用
- OS固有の低レベル機能は使用しない
- クロスコンパイルで十分な品質を確保可能

追加の品質保証として、macOS専用テストワークフローも用意していますが、リリースビルドはUbuntuランナーでのクロスコンパイルで問題ありません。