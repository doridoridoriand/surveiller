# 機能要件書

## はじめに

deadman-go は、既存の Python 製 deadman ツールを Go 言語で再実装した死活監視ツールです。ICMP ping による複数ホストの疎通監視を行い、curses ベースの TUI で状態を可視化します。Go の特性を活かした軽量・高並列・単一バイナリ配布を実現し、将来的な Prometheus/Grafana 連携の基盤を提供します。

## 用語集

- **deadman-go**: Go 言語で実装された死活監視ツール
- **ターゲット**: 監視対象のホスト（IPアドレスまたはホスト名）
- **TUI**: Terminal User Interface（ターミナルベースのユーザーインターフェース）
- **RTT**: Round Trip Time（往復遅延時間）
- **ICMP**: Internet Control Message Protocol（ping で使用されるプロトコル）
- **設定ファイル**: deadman.conf 形式のターゲット定義ファイル
- **グループ**: 関連するターゲットをまとめる論理的な単位

## 要件

### 要件 1

**ユーザーストーリー:** システム管理者として、複数のホストの死活状態を一元的に監視したいので、設定ファイルでターゲットを定義できるようにしたい

#### 受入基準

1. WHEN ユーザーが設定ファイルを作成する THEN システムは `ラベル アドレス` 形式でターゲットを定義できる
2. WHEN 設定ファイルに `---` 区切りが含まれる THEN システムはターゲットをグループ別に分類する
3. WHEN 設定ファイルに `# deadman-go:` で始まるコメント行がある THEN システムはグローバル設定として解釈する
4. WHEN 設定ファイルに `#` で始まる通常のコメント行がある THEN システムはそれを無視する
5. WHEN 設定ファイルが読み込まれる THEN システムは構文エラーを検出して適切なエラーメッセージを表示する

### 要件 2

**ユーザーストーリー:** ネットワーク管理者として、各ホストの疎通状態をリアルタイムで把握したいので、ICMP ping による死活監視を実行したい

#### 受入基準

1. WHEN システムがターゲットに ping を送信する THEN システムは ICMP echo request を使用する
2. WHEN ping が成功する THEN システムは RTT を計測して記録する
3. WHEN ping が失敗する THEN システムは失敗回数をカウントして状態を更新する
4. WHEN 連続失敗回数が閾値を超える THEN システムはターゲットの状態を DOWN に変更する
5. WHEN ping の応答時間がタイムアウトを超える THEN システムはそれを失敗として扱う

### 要件 3

**ユーザーストーリー:** 運用担当者として、監視状態を視覚的に確認したいので、TUI で各ターゲットの状態と RTT を表示したい

#### 受入基準

1. WHEN TUI が起動する THEN システムは各ターゲットの名前、アドレス、状態、RTT を表示する
2. WHEN ターゲットがグループ分けされている THEN システムはグループごとに区切り線を表示する
3. WHEN RTT が更新される THEN システムは TUI 上でバーグラフ形式で RTT を表示する
4. WHEN ターゲットの状態が変化する THEN システムは TUI 上で状態表示を即座に更新する
5. WHEN ユーザーが 'q' キーを押す THEN システムは TUI を終了する

### 要件 4

**ユーザーストーリー:** システム管理者として、大量のホストを効率的に監視したいので、並列処理による高性能な監視を実現したい

#### 受入基準

1. WHEN 複数のターゲットが定義されている THEN システムは各ターゲットを独立した goroutine で監視する
2. WHEN 同時実行 ping 数が上限に達する THEN システムはセマフォで制御して ping ストームを防ぐ
3. WHEN 監視間隔が設定されている THEN システムは各ターゲットを指定された間隔で監視する
4. WHEN システムが終了要求を受ける THEN システムは全ての goroutine を適切に終了する
5. WHEN 100-1000 ホストが監視対象である THEN システムは 1-5 秒間隔で安定して監視を継続する

### 要件 5

**ユーザーストーリー:** 運用担当者として、設定変更を即座に反映したいので、実行中に設定ファイルをリロードできるようにしたい

#### 受入基準

1. WHEN SIGHUP シグナルを受信する THEN システムは設定ファイルを再読み込みする
2. WHEN 設定リロード時にターゲットが追加されている THEN システムは新しいターゲットの監視を開始する
3. WHEN 設定リロード時にターゲットが削除されている THEN システムは該当ターゲットの監視を停止する
4. WHEN 設定リロード時にエラーが発生する THEN システムは既存の設定を維持してエラーログを出力する
5. WHEN 設定リロードが成功する THEN システムは可能な限り既存ターゲットの履歴を保持する

### 要件 6

**ユーザーストーリー:** 開発者として、システムの動作状況を把握したいので、構造化されたログを出力したい

#### 受入基準

1. WHEN システムが動作する THEN システムは重要なイベントを構造化ログとして出力する
2. WHEN ping の成功/失敗が発生する THEN システムはターゲット名、結果、RTT をログに記録する
3. WHEN 設定ファイルの読み込みが行われる THEN システムは読み込み結果をログに記録する
4. WHEN エラーが発生する THEN システムは詳細なエラー情報をログに出力する
5. WHEN ログレベルが設定されている THEN システムは指定されたレベル以上のログのみを出力する

### 要件 7

**ユーザーストーリー:** システム管理者として、様々な環境で簡単にデプロイしたいので、単一バイナリとして配布したい

#### 受入基準

1. WHEN システムをビルドする THEN システムは静的リンクされた単一バイナリを生成する
2. WHEN バイナリを Linux 環境で実行する THEN システムは外部依存なしで動作する
3. WHEN コンテナイメージが作成される THEN システムは Alpine ベースの軽量イメージを提供する
4. WHEN バイナリサイズが測定される THEN システムは実用的なサイズ（数十MB以下）を維持する
5. WHEN ICMP 権限が不足する THEN システムは適切なエラーメッセージを表示する

### 要件 8

**ユーザーストーリー:** 運用担当者として、監視設定を柔軟に調整したいので、CLI オプションで設定を上書きできるようにしたい

#### 受入基準

1. WHEN CLI で監視間隔を指定する THEN システムは設定ファイルの値より CLI の値を優先する
2. WHEN CLI でタイムアウト値を指定する THEN システムは指定された値で ping タイムアウトを設定する
3. WHEN CLI で同時実行数を指定する THEN システムは指定された値で並列度を制御する
4. WHEN CLI で TUI 無効オプションを指定する THEN システムはログのみで動作する
5. WHEN 無効な CLI オプションが指定される THEN システムは適切なヘルプメッセージを表示する